#!/usr/bin/perl -wT
# 
# Matija Nalis <mnalis-perl@voyager.hr> GPLv3+ started on 2018-03-21
# 
# logira kretanje kamata na stednju u HR
#

use strict;
use autodie qw(:all);
use feature qw(say);


my $DB='dbi:SQLite:dbname=kamate.db';	# undef to skip database ops
my $DBUSER='';
my $DBPASS='';

my $DIR = './banks';
%ENV = ( PATH => '/usr/local/bin:/usr/bin:/bin' );

my $DEBUG = $ENV{DEBUG} || 0;

use WWW::Mechanize;
use DBI;

# debug helper
sub dbg($$) {
	my ($level, $txt) = @_;
	die "invalid call: dbg($level,$txt)" if $level !~ /^\d{1,3}$/;
	if ($DEBUG >= $level) {
		print "  " x ($level-1);	# ident
		say $txt;
	}
}


# pronalazi najbolju kamatu u zadanom stringu po regexu
sub find_max_kamata_regex($$) {
	my ($html, $regex) = @_;
	our $best_kamata = 0;

	# provjera kamate
	sub check_kamata($) {
		my ($pct) = @_;
		dbg 5, "provjeravam kamatu $pct <=> $best_kamata";
		$best_kamata = $pct if $pct > $best_kamata;
	}

	dbg 4, "using regex: $regex";
	dbg 8, "got HTML content: $html";
	$html =~ s{$regex}{check_kamata("$1.$2")}ge;
	dbg 3, "best_kamata=$best_kamata";
	return $best_kamata;
}


# pronalazi max kamatu sa zadanim $PRE i $POST u standardnom regexpu
sub find_max_kamata_pp($$$) {
	my ($html, $pre, $post) = @_;
	my $regex = "$pre" . '(\d{1,3})[.,](\d{2})' . "$post";
	return find_max_kamata_regex($html, $regex);
}


# fetches URL and returns content as string
sub fetch_url($) {
	my ($url) = @_;
	my $mech = WWW::Mechanize->new();
	dbg 2, "Getting $url";
	$mech->get($url);
	die "can't fetch $url: " . $mech->response() if !$mech->success();
	return $mech->content;
}

# povlaci zadani URL i vraca najbolju kamatu koju pronadje na stranici a matchira $PRE i $POST
sub best_kamata_html_mpp($$$$) {
	my ($url, $match, $pre, $post) = @_;
	my $html = fetch_url($url);
	if ($match) {
		dbg 4, "matching only code in $match";
		if ($html =~ /$match/si) { $html = $1 } else { die "$html\ndoesn't match $match" } 
	}
	return find_max_kamata_pp($html, $pre, $post);
}

# povlaci zadani URL i vraca najbolju kamatu koju pronadje na stranici sa default formatom: x,xx% 
sub best_kamata_html_def($) {
	my ($url) = @_;
	return best_kamata_html_mpp ($url, undef, '\b', '\s*\%');
}

###############################################
# here goes the main
###############################################


opendir(my $dh, $DIR) || die "Can't opendir $DIR: $!";
my @banks = grep { /\.pm$/ && -f "$DIR/$_" } readdir($dh);
closedir $dh;

@banks = @ARGV if scalar @ARGV > 0;

my $dbh;
if ($DB) {
	$dbh = DBI->connect("$DB","$DBUSER","$DBPASS");
	$dbh->do ("CREATE TABLE IF NOT EXISTS kamate (
			bank varchar(60),
			pct10 int,
			datum int DEFAULT CURRENT_DATE,
			UNIQUE (datum,bank) )
		") or die $dbh->errstr;
	$dbh->begin_work or die $dbh->errstr;
}

foreach my $bank (@banks) {
	my $bankcmd;
	if ($bank =~ /^([a-z0-9_-]+\.pm)$/) { $bankcmd = "$DIR/$1" } else { die "invalid bank name: $bank" }
	if (! -r "$bankcmd" ) { die "can't read bank $bank in cmd $bankcmd" }
	dbg 1, "*** Processing bank: $bank";
	my $ret = require "$bankcmd";
	# FIXME check if it worked, return level itd
	say "$ret\t$bank";
	if ($DB) {
		my $sth = $dbh->prepare ('REPLACE INTO kamate (bank,pct10) VALUES (?,?)') or die $dbh->errstr;
		$sth->execute ($bank, $ret*100) or die $sth->errstr;
	}
}

$dbh->commit or die $dbh->errstr;
